/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

/// Taken from `wordrecg.nim` and sorted
const RESERVED_KEYWORDS: &[&str] = &[
    "acyclic",
    "addr",
    "align",
    "alignas",
    "alignof",
    "and",
    "as",
    "asm",
    "asmnostackframe",
    "assertions",
    "auto",
    "base",
    "bind",
    "bitsize",
    "block",
    "bool",
    "booldefine",
    "borrow",
    "boundchecks",
    "break",
    "bycopy",
    "byref",
    "callconv",
    "case",
    "cast",
    "catch",
    "cdecl",
    "char",
    "char16_t",
    "char32_t",
    "checks",
    "class",
    "closure",
    "codegendecl",
    "compile",
    "compilerproc",
    "compiletime",
    "compl",
    "computedgoto",
    "concept",
    "const_cast",
    "const",
    "constexpr",
    "constructor",
    "continue",
    "converter",
    "core",
    "deadcodeelim",
    "debugger",
    "decltype",
    "default",
    "defer",
    "define",
    "delegator",
    "delete",
    "deprecated",
    "destructor",
    "dirty",
    "discard",
    "discardable",
    "distinct",
    "div",
    "do",
    "double",
    "dynamic_cast",
    "dynlib",
    "effects",
    "elif",
    "else",
    "emit",
    "end",
    "enum",
    "error",
    "except",
    "executeonreload",
    "experimental",
    "explain",
    "explicit",
    "export",
    "exportc",
    "exportcpp",
    "exportnims",
    "extern",
    "false",
    "fastcall",
    "fatal",
    "fieldchecks",
    "final",
    "finally",
    "float",
    "floatchecks",
    "for",
    "friend",
    "from",
    "func",
    "gcsafe",
    "gensym",
    "global",
    "goto",
    "guard",
    "header",
    "hint",
    "hints",
    "if",
    "immediate",
    "implicitstatic",
    "import",
    "importc",
    "importcompilerproc",
    "importcpp",
    "importjs",
    "importobjc",
    "in",
    "include",
    "incompletestruct",
    "infchecks",
    "inheritable",
    "inject",
    "injectstmt",
    "inline",
    "inout",
    "int",
    "intdefine",
    "interface",
    "is",
    "isnot",
    "iterator",
    "let",
    "lib",
    "liftlocals",
    "line",
    "linearscanend",
    "linedir",
    "linetrace",
    "link",
    "linksys",
    "locks",
    "long",
    "macro",
    "magic",
    "memtracker",
    "merge",
    "method",
    "mixin",
    "mod",
    "mutable",
    "namespace",
    "nanchecks",
    "new",
    "nil",
    "nilchecks",
    "nimcall",
    "noconv",
    "nodecl",
    "nodestroy",
    "noexcept",
    "noforward",
    "noinit",
    "noinline",
    "nonreloadable",
    "noreturn",
    "norewrite",
    "nosideeffect",
    "not",
    "notin",
    "nullptr",
    "objchecks",
    "object",
    "of",
    "off",
    "on",
    "oneway",
    "operator",
    "optimization",
    "or",
    "out",
    "overflowchecks",
    "override",
    "package",
    "packed",
    "partial",
    "passc",
    "passl",
    "patterns",
    "pop",
    "pragma",
    "private",
    "proc",
    "procvar",
    "profiler",
    "protected",
    "ptr",
    "public",
    "pure",
    "push",
    "raise",
    "raises",
    "rangechecks",
    "reads",
    "ref",
    "register",
    "reinterpret_cast",
    "reorder",
    "requiresinit",
    "restrict",
    "return",
    "safecall",
    "safecode",
    "shallow",
    "shl",
    "short",
    "shr",
    "sideeffect",
    "signed",
    "size",
    "sizeof",
    "stacktrace",
    "static_assert",
    "static_cast",
    "static",
    "stdcall",
    "stderr",
    "stdin",
    "stdout",
    "strdefine",
    "struct",
    "stylechecks",
    "subschar",
    "switch",
    "syscall",
    "tags",
    "template",
    "this",
    "thread_local",
    "thread",
    "threadvar",
    "throw",
    "trmacros",
    "true",
    "try",
    "tuple",
    "type",
    "typedef",
    "typeid",
    "typename",
    "typeof",
    "unchecked",
    "undef",
    "union",
    "unroll",
    "unsigned",
    "used",
    "using",
    "var",
    "varargs",
    "virtual",
    "void",
    "volatile",
    "warning",
    "warnings",
    "wchar_t",
    "when",
    "while",
    "write",
    "writes",
    "xor",
    "yield",
];

pub fn escape(rust_identifier: &mut String) {
    if RESERVED_KEYWORDS
        .binary_search(&rust_identifier.as_ref())
        .is_ok()
    {
        rust_identifier.push('x');
    }

    if rust_identifier.starts_with("_") {
        rust_identifier.insert(0, 'x');
    }
}

pub fn escaped(rust_identifier: &str) -> String {
    let mut ret = rust_identifier.to_string();
    escape(&mut ret);
    ret
}
